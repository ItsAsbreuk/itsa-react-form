<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/component.jsx - itsa-react-xxxxx</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="https://avatars0.githubusercontent.com/u/8314644?v=3&amp;s=84" title="itsa-react-xxxxx"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Form.html">Form</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/itsa-react-form.html">itsa-react-form</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/component.jsx</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * React-component: Form, which renders a focussable form based upon
 * elements declared by &#x60;props.items&#x60;
 *
 * The generated forms have &#x60;purecss&#x60; styles (see http://purecss.io), but you still need to load purecss
 * yourself to get these styles activated.
 *
 * &lt;i&gt;Copyright (c) 2016 AcceleTrial - https://acceletrial.com&lt;/i&gt;&lt;br&gt;
 * Proprietary License
 *
 * Using native elements:
 * You can use native elements by specifying a &quot;String&quot; to &#x60;component&#x60;.
 * Some native elements can use innerHTML, innerText or children, by setting the property: &#x60;innerHTML&#x60;, &#x60;innerText&#x60; or &#x60;children.
 *
 * @example
 * items = [
 *     {component: &#x27;legend&#x27;, innerHTML: &#x27;&lt;b&gt;Beautiful&lt;/b&gt; items&#x27;},
 *     {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;, children: []},
 *     [
 *         [ // column 1
 *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
 *         ],
 *         [ // column 2
 *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
 *         ]
 *     ]
 * ];
 *
 * A special purpose would be to have multiple items in the same row or inside a fieldset. To achieve this, define the type as
 * &quot;row&quot;, &quot;control-row&quot; or &quot;fieldset&quot; (String) as well as the property &#x60;items&#x60;.
 * @example
 * items = [
 *     {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;},
 *     [
 *         [ // column 1
 *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
 *         ],
 *         [ // column 2
 *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
 *         ]
 *     ],
 *     {
 *         type: &quot;fieldset&quot;,
 *         items: [
 *             {component: Button, props: {buttonText: &#x27;cancel&#x27;}},
 *             {component: Button, props: {buttonText: &#x27;save&#x27;}}
 *         ]
 *     },
 *     {
 *         type: &quot;row&quot;,
 *         items: [
 *             {component: Button, props: {buttonText: &#x27;cancel&#x27;}},
 *             {component: Button, props: {buttonText: &#x27;save&#x27;}}
 *         ]
 *     }
 * ];
 *
 * @module itsa-react-form
 * @class Form
 * @since 0.0.1
*/

&#x27;use strict&#x27;;

require(&#x27;itsa-jsext/lib/object&#x27;);

const React = require(&#x27;react&#x27;),
    PropTypes = React.PropTypes,
    FocusContainer = require(&#x27;itsa-react-focuscontainer&#x27;),
    MAIN_CLASS = &#x27;itsa-form&#x27;,
    WARNING_COLUMN_ARRAY = &#x27;Form-columns should have an array-item for each column&#x27;;

const Form = React.createClass({

    propTypes: {
        /**
         * The Component its children
         *
         * @property children
         * @type Object || Array
         * @since 15.0.0
        */
        children: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),

        /**
         * The classname for the container
         *
         * @property className
         * @type String
         * @since 15.0.0
        */
        className: PropTypes.string,

        /**
         * Whether the focuscontainer is disabled (doesn&#x27;t response to focusevents)
         *
         * @property disabled
         * @type Boolean
         * @since 15.0.0
        */
        disabled: PropTypes.bool,

        /**
         * Whether a click on the container (outside its elements,
         * should lead into focussing the container
         *
         * @property focusOnContainerClick
         * @default false
         * @type Boolean
         * @since 15.0.10
        */
        focusOnContainerClick: PropTypes.bool,

        /**
         * A &#x60;selector&#x60; or &#x60;index&#x60; of the focussable items that should get the initial focus.
         * In case of a selector, it might return multiple nodes: the one that is being used
         * is determined by
         *
         * @property initialFocus
         * @type String|Number
         * @since 15.0.0
        */
        initialFocus: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

        /**
         * In case &#x60;initialFocus&#x60; is a selector, it might return multiple nodes: the one that is being used.
         * In case of &quot;last&quot;, it will return the last node.
         *
         * @property initialFocusIndex
         * @type Number|&quot;last&quot;
         * @default 0
         * @since 15.0.0
        */
        initialFocusIndex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

        /**
         * The list of the items that should be rendered. Each item consist of an object like this:
         * {component: ReactComponent, props: this.props, label: &quot;mylabel&quot;},
         * where the label is optional.
         *
         * If an item is an array, then this row will become devided in the number of columns that equal the array-size.
         * Inside the array, there should be ONLY array-items, defining the content of the column,
         *
         * Using native elements:
         * You can use native elements by specifying a &quot;String&quot; to &#x60;component&#x60;.
         * Some native elements can use innerHTML, innerText or children, by setting the property: &#x60;innerHTML&#x60;, &#x60;innerText&#x60; or &#x60;children.
         *
         * @example
         * items = [
         *     {component: &#x27;legend&#x27;, innerHTML: &#x27;&lt;b&gt;Beautiful&lt;/b&gt; items&#x27;},
         *     {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;, children: []},
         *     [
         *         [ // column 1
         *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
         *         ],
         *         [ // column 2
         *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
         *         ]
         *     ]
         * ];
         *
         * A special purpose would be to have multiple items in the same row or inside a fieldset. To achieve this, define the type as
         * &quot;row&quot;, &quot;control-row&quot; or &quot;fieldset&quot; (String) as well as the property &#x60;items&#x60;.
         * @example
         * items = [
         *     {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;},
         *     [
         *         [ // column 1
         *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
         *         ],
         *         [ // column 2
         *             {component: Input, props: {value: &#x27;Clinton&#x27;}, label: &quot;name&quot;}
         *         ]
         *     ],
         *     {
         *         type: &quot;fieldset&quot;,
         *         items: [
         *             {component: Button, props: {buttonText: &#x27;cancel&#x27;}},
         *             {component: Button, props: {buttonText: &#x27;save&#x27;}}
         *         ]
         *     },
         *     {
         *         type: &quot;row&quot;,
         *         items: [
         *             {component: Button, props: {buttonText: &#x27;cancel&#x27;}},
         *             {component: Button, props: {buttonText: &#x27;save&#x27;}}
         *         ]
         *     }
         * ];
         *
         * @property items
         * @type Array
         * @default 0
         * @since 15.0.0
        */
        items: PropTypes.array,

        /**
         * What key/keys are responsible for re-focussing &#x60;down&#x60;. Valid values are charcodes possible prepende with
         * a special key: 9 or &#x60;shift+9&#x60; or &#x60;ctrl+shift+9&#x60;. Multiple key combinations can be defined bydefining an array of keyDown-values.
         *
         * @property keyDown
         * @default 9
         * @type String|number|Array
         * @since 15.0.0
        */
        keyDown: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

        /**
         * Whenever &#x60;keyEnter&#x60; is set, then the focus-container will become a &#x60;nested&#x60;- focuscontainer.
         * Nested focuscontainers will automaticcaly become focussable by their parent-container.
         *
         * The &#x60;keyEnter&#x60; determines what key/keys are responsible for &#x60;entering&#x60; this container. Valid values are charcodes possible prepende with
         * a special key: 39 or &#x60;shift+39&#x60; or &#x60;ctrl+shift+39&#x60;. Multiple key combinations can be defined bydefining an array of keyUp-values.
         *
         * @property keyEnter
         * @type String|number|Array
         * @since 15.0.0
        */
        keyEnter: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

        /**
         * The &#x60;keyLeave&#x60; determines what key/keys are responsible for &#x60;leaving&#x60; this container and go to the parent focus-container.
         * Valid values are charcodes possible prepende with
         * a special key: 39 or &#x60;shift+39&#x60; or &#x60;ctrl+shift+39&#x60;. Multiple key combinations can be defined bydefining an array of keyUp-values.
         *
         * @property keyLeave
         * @default 27
         * @type String|number|Array
         * @since 15.0.0
        */
        keyLeave: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

        /**
         * What key/keys are responsible for re-focussing &#x60;up&#x60;. Valid values are charcodes possible prepended with
         * a special key: 9 or &#x60;shift+9&#x60; or &#x60;ctrl+shift+9&#x60;. Multiple key combinations can be defined bydefining an array of keyUp-values.
         *
         * @property keyUp
         * @default &quot;shift+9&quot;
         * @type String|number|Array
         * @since 15.0.0
        */
        keyUp: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),

        /**
         * Whether the loop the focus when the last/first item is reached.
         *
         * @property loop
         * @default true
         * @type Boolean
         * @since 15.0.0
        */
        loop: PropTypes.bool,

        /**
         * Callback for when the component did mount.
         *
         * @property onMount
         * @type Function
         * @since 15.0.8
        */
        onMount: PropTypes.func,

        /**
         * Callback whenever the forms needs to submit (button[type=&quot;submit&quot;] gets pressed)
         *
         * @property onClick
         * @type Function
         * @since 0.0.1
        */
        onSubmit: PropTypes.func,

        /**
         * Callback whenever the forms needs to submit (button[type=&quot;reset&quot;] gets pressed)
         *
         * @property onClick
         * @type Function
         * @since 0.0.1
        */
        onReset: PropTypes.func,

        /**
         * Whether to focus on the next item whenever a &#x60;enter&#x60; is pressed on an input-element.
         *
         * @property refocusOnEnterInput
         * @default true
         * @type Boolean
         * @since 15.0.0
        */
        refocusOnEnterInput: PropTypes.bool,

        /**
         * Selector on which the focusmanager should check against when refocussing
         *
         * @property selector
         * @type String
         * @since 15.0.0
        */
        selector: PropTypes.string,

        /**
         * Inline styles for the focus-container
         *
         * @property style
         * @type Object
         * @since 15.0.0
        */
        style: PropTypes.object,

        /**
         * The tabIndex
         *
         * @property tabIndex
         * @type Number
         * @since 0.0.1
        */
        tabIndex: PropTypes.number,

        /**
         * The transition-time when the window needs to be scrolled in order to get the focussable node into the view.
         *
         * @property transitionTime
         * @type Number
         * @since 15.0.0
        */
        transitionTime: PropTypes.number
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormCols
     * @return ReactComponents
     * @since 2.0.0
     */
    _create1Col(cols, i) {
        let formitems;
        const instance = this,
            items = cols[0];
        if (!Array.isArray(items)) {
            console.warn(WARNING_COLUMN_ARRAY);
        }
        else {
            formitems = instance._processItems(items);
            return (
                 &lt;div className=&quot;pure-g&quot; key={i} &gt;
                    &lt;div className=&quot;pure-u-1&quot;&gt;{formitems}&lt;/div&gt;
                &lt;/div&gt;
           );
        }
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormCols
     * @return ReactComponents
     * @since 2.0.0
     */
    _create2Cols(cols, i) {
        let formitemsCol1, formitemsCol2;
        const instance = this,
            itemsCol1 = cols[0],
            itemsCol2 = cols[1];
        if (!Array.isArray(itemsCol1) || !Array.isArray(itemsCol2)) {
            console.warn(WARNING_COLUMN_ARRAY);
        }
        else {
            formitemsCol1 = instance._processItems(itemsCol1);
            formitemsCol2 = instance._processItems(itemsCol2);
            return (
                 &lt;div className=&quot;pure-g&quot; key={i}&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2&quot;&gt;{formitemsCol1}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2&quot;&gt;{formitemsCol2}&lt;/div&gt;
                &lt;/div&gt;
           );
        }
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormCols
     * @return ReactComponents
     * @since 2.0.0
     */
    _create3Cols(cols, i) {
        let formitemsCol1, formitemsCol2, formitemsCol3;
        const instance = this,
            itemsCol1 = cols[0],
            itemsCol2 = cols[1],
            itemsCol3 = cols[2];
        if (!Array.isArray(itemsCol1) || !Array.isArray(itemsCol2) || !Array.isArray(itemsCol3)) {
            console.warn(WARNING_COLUMN_ARRAY);
        }
        else {
            formitemsCol1 = instance._processItems(itemsCol1);
            formitemsCol2 = instance._processItems(itemsCol2);
            formitemsCol3 = instance._processItems(itemsCol3);
            return (
                 &lt;div className=&quot;pure-g&quot; key={i}&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-3&quot;&gt;{formitemsCol1}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-3&quot;&gt;{formitemsCol2}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-4&quot;&gt;{formitemsCol3}&lt;/div&gt;
                &lt;/div&gt;
           );
        }
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormCols
     * @return ReactComponents
     * @since 2.0.0
     */
    _create4Cols(cols, i) {
        let formitemsCol1, formitemsCol2, formitemsCol3, formitemsCol4;
        const instance = this,
            itemsCol1 = cols[0],
            itemsCol2 = cols[1],
            itemsCol3 = cols[2],
            itemsCol4 = cols[3];
        if (!Array.isArray(itemsCol1) || !Array.isArray(itemsCol2) || !Array.isArray(itemsCol3) || !Array.isArray(itemsCol4)) {
            console.warn(WARNING_COLUMN_ARRAY);
        }
        else {
            formitemsCol1 = instance._processItems(itemsCol1);
            formitemsCol2 = instance._processItems(itemsCol2);
            formitemsCol3 = instance._processItems(itemsCol3);
            formitemsCol4 = instance._processItems(itemsCol4);
            return (
                 &lt;div className=&quot;pure-g&quot; key={i}&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2 pure-u-lg-1-4&quot;&gt;{formitemsCol1}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2 pure-u-lg-1-4&quot;&gt;{formitemsCol2}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2 pure-u-lg-1-4&quot;&gt;{formitemsCol3}&lt;/div&gt;
                    &lt;div className=&quot;pure-u-1 pure-u-md-1-2 pure-u-lg-1-4&quot;&gt;{formitemsCol4}&lt;/div&gt;
                &lt;/div&gt;
           );
        }
    },

    _processItems(items) {
        let newItems = [];
        const instance = this;
        items.forEach((item, i) =&gt; {
            if (Array.isArray(item)) {
                // create a multicolumn div
                newItems.push(instance.createFormCols(item, i));
            }
            else {
                // found an object
                if ((item.type===&#x27;row&#x27;) || (item.type===&#x27;control-row&#x27;)) {
                    // create a row with items
                    newItems.push(instance.createFormRow(item, i, (item.type===&#x27;row&#x27;)));
                }
                else if (item.type===&#x27;fieldset&#x27;) {
                    // create a row with items
                    newItems.push(instance.createFormFieldset(item, i));
                }
                else {
                    // single item
                    newItems.push(instance.createFormElement(item, i));
                }
            }
        });
        return newItems;
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormCols
     * @return ReactComponents
     * @since 2.0.0
     */
    createFormCols(cols, i) {
        let formCol;
        const instance = this,
            len = cols.length;
        if (len===1) {
            formCol = instance._create1Col(cols, i);
        }
        else if (len===2) {
            formCol = instance._create2Cols(cols, i);
        }
        else if (len===3) {
            formCol = instance._create3Cols(cols, i);
        }
        else if (len===4) {
            formCol = instance._create4Cols(cols, i);
        }
        if (len&gt;4) {
            console.warn(&#x27;Form cannot create more than 4 columns (trying to create &#x27;+len+&#x27; columns)&#x27;);
        }
        return formCol;
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormElement
     * @return ReactComponent
     * @since 2.0.0
     */
    createFormElement(item, i) {
        let childrenArray, label, innerHTML, component, Component;
        const propsLabel = item.label,
            itemComponent = item.component,
            itemProps = item.props,
            props = itemProps.itsa_deepClone(),
            innerText = itemProps.innerText,
            children = itemProps.children,
            itemInnerHTML = item.innerHTML;
        delete props.innerText;
        delete props.children;
        if (propsLabel!==undefined) {
            label = &lt;label htmlFor={props.name}&gt;{propsLabel}&lt;/label&gt;;
        }
        if (itemInnerHTML) {
            innerHTML = {__html: itemInnerHTML};
        }

        if (typeof itemComponent===&#x27;string&#x27;) {
            childrenArray = [];
            innerText &amp;&amp; childrenArray.push(innerText);
            children &amp;&amp; Array.prototype.push.apply(childrenArray, children);
            component = React.createElement(itemComponent, props, childrenArray);
        }
        else {
            Component = itemComponent;
            component = (
                &lt;Component {...props} &gt;
                    {innerText}
                    {children}
                &lt;/Component&gt;
            );
        }
        return (
            &lt;div className=&quot;pure-control-group&quot; dangerouslySetInnerHTML={innerHTML} key={i}&gt;
                {propsLabel}
                {component}
            &lt;/div&gt;
        );
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormRow
     * @return [ReactComponent]
     * @since 2.0.0
     */
    createFormRow(item, i, isFullRow) {
        let props = item.itsa_deepClone(),
            rowItems = [],
            classname;
        delete props.items;
        item.items.forEach((item, i) =&gt; {
            let props;
            const Component = item.component,
                itemProps = item.props,
                innerText = itemProps.innerText,
                children = itemProps.children;
            if (Array.isArray(item)) {
                console.warn(&#x27;Form-rows must exist of a list of elements: they cannot process an Array&#x27;);
            }
            else {
                props = itemProps.itsa_deepClone();
                delete props.innerText;
                delete props.children;
                rowItems.push((&lt;Component {...props} key={i} &gt;
                    {innerText}
                    {children}
                &lt;/Component&gt;));
            }
        });
        classname = isFullRow ? &#x27;pure-control-group&#x27; : &#x27;pure-controls&#x27;;
        if (props.className) {
            classname += &#x27; &#x27;+props.className;
            delete props.className;
        }
        return (
            &lt;div {...props} className={classname} key={i}&gt;{rowItems}&lt;/div&gt;
        );
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method createFormRow
     * @return [ReactComponent]
     * @since 2.0.0
     */
    createFormFieldset(item, i) {
        let props = item.itsa_deepClone();
        const fieldsetItems = this._processItems(item.items);
        delete props.items;
        return (
            &lt;fieldset {...props} key={i}&gt;{fieldsetItems}&lt;/fieldset&gt;
        );
    },

    handleClick(e) {
        const instance = this,
            node = e.target,
            type = node.getAttribute(&#x27;type&#x27;),
            props = instance.props,
            onReset = props.onReset,
            onSubmit = props.onSubmit;
        if (type===&#x27;reset&#x27;) {
            onReset &amp;&amp; onReset(e);
        }
        else if (type===&#x27;submit&#x27;) {
            onSubmit &amp;&amp; onSubmit(e);
        }
    },

    /**
     * React render-method --&gt; renders the Component.
     *
     * @method render
     * @return ReactComponents
     * @since 2.0.0
     */
    render() {
        let classname = MAIN_CLASS,
            handleClick;
        const instance = this,
            props = instance.props,
            items = instance._processItems(props.items),
            propsClassname = props.className;
        propsClassname &amp;&amp; (classname+=&#x27; &#x27;+propsClassname);
        if (props.onSubmit || props.onReset) {
            handleClick = instance.handleClick;
        }
        return (
            &lt;FocusContainer
                {...props}
                className={classname}
                onClick={handleClick} &gt;
                {items}
            &lt;/FocusContainer&gt;
        );
    }

});

module.exports = Form;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
